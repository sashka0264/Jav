## Различия между ООП и ФП
Если попробовать объяснить коротко и максимально точно разницу между ООП и ФП, то ООП - это работа с данными через полиморфизм, наследование и инкапсуляцию, а ФП - это работа с данными с помощью функций (чистая функция, функция вышего порядка). 

## Область видимости
Область видимости - это пространство имен переменных с определенным доступом к ним.

## Замыкания
Замыкание - это способность функции запоминать свою лексическую область видимости вне зависимости от того, где она вызывается.

## Структуры данных
Структуры данных - связные списки, массивы, очереди (first in, first out), стэк (first in, last out), хэш таблицы, деревья, графы. 

## Императивное/деклоративное программирование
* Императивное - описываю порядок действий.
* Деклоративное - описываю процесс (например, пишу сначала все function declaration, а потом уже пишу код).

## This
This - это обьект, зависящий от контекста в котором он применяется. Он может динамически изменяться. Назначается в момент вызова.

## Функция 
Функция - это какой-то отдельный блок кода, который можно, один раз объявив, вызывать столько раз, сколько нужно
Все переменные внутри функции – это свойства специального скрытого внутреннего объекта "лексическое окружение" который создаётся при её запуске.

**Повтори Swagger, всплытие событий, GraphQL**

**Прототип** - это обьект. Каждый обьект в JS имеет скрытую ссылку на null или на другой обьект, который будет его прототипом. 

## Отличие let от const
* Переменная, обьявленная через var, всплывает (доступна до обьявления) и равна undefined.
* Переменная, обьявленная через var, имеет функциональную область видимости, а через let/const - блочную. Вот хороший пример.
```
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); 
    }, 1000); 
}; 
```
В данном случае '10' 10 раз, потому что var игнорирует скобки, и переменная i существует лишь 1 раз - и будет равна 10 в момент выполнения тасок (вспомни, что i через var будет доступна даже вне цикла). А при let на каждой итерации будет своя новая переменная, которая будет браться из замыкания. Задачу можно исправить так:
```
for (var i = 0; i < 10; i++) {
    setTimeout(function(index) {
        return function() {
        console.log(index);
        };
    }(i), 1000);
};
```